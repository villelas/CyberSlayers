// GalagaGame.jsx
import React, { useState, useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';

const DASHBOARD_ROUTE = '/dashboard'; // change if your dashboard route is different

const GAME_WIDTH = 480;
const GAME_HEIGHT = 640;

const PLAYER_WIDTH = 30;
const PLAYER_HEIGHT = 20;
const PLAYER_SPEED = 5;

const BULLET_WIDTH = 4;
const BULLET_HEIGHT = 10;
const BULLET_SPEED = 8;

const ENEMY_WIDTH = 26;
const ENEMY_HEIGHT = 20;
const ENEMY_ROWS = 4;
const ENEMY_COLS = 8;
const ENEMY_X_SPACING = 50;
const ENEMY_Y_SPACING = 40;
const ENEMY_START_Y = 80;
const ENEMY_SPEED_X = 1.5;
const ENEMY_STEP_DOWN = 10;

const TICK_MS = 16; // ~60 FPS

export default function GalagaGame() {
  const navigate = useNavigate();

  const [playerX, setPlayerX] = useState(GAME_WIDTH / 2 - PLAYER_WIDTH / 2);
  const [bullets, setBullets] = useState([]); // {x, y}
  const [enemies, setEnemies] = useState(() => createInitialEnemies());
  const [enemyDirection, setEnemyDirection] = useState(1); // 1 = right, -1 = left
  const [enemyOffsetY, setEnemyOffsetY] = useState(0);
  const [keys, setKeys] = useState({ left: false, right: false, shoot: false });
  const [gameState, setGameState] = useState('playing'); // 'playing' | 'win' | 'lose'
  const [score, setScore] = useState(0);

  const lastShotTimeRef = useRef(0);
  const shootCooldown = 200; // ms between shots

  // Keyboard handling
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'a') {
        setKeys((k) => ({ ...k, left: true }));
      } else if (e.key === 'ArrowRight' || e.key === 'd') {
        setKeys((k) => ({ ...k, right: true }));
      } else if (e.key === ' ' || e.key === 'ArrowUp' || e.key === 'w') {
        setKeys((k) => ({ ...k, shoot: true }));
      }
    };

    const handleKeyUp = (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'a') {
        setKeys((k) => ({ ...k, left: false }));
      } else if (e.key === 'ArrowRight' || e.key === 'd') {
        setKeys((k) => ({ ...k, right: false }));
      } else if (e.key === ' ' || e.key === 'ArrowUp' || e.key === 'w') {
        setKeys((k) => ({ ...k, shoot: false }));
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  // Game loop
  useEffect(() => {
    if (gameState !== 'playing') return;

    const interval = setInterval(() => {
      setPlayerX((prevX) => {
        let x = prevX;
        if (keys.left && !keys.right) x -= PLAYER_SPEED;
        if (keys.right && !keys.left) x += PLAYER_SPEED;
        if (x < 0) x = 0;
        if (x > GAME_WIDTH - PLAYER_WIDTH) x = GAME_WIDTH - PLAYER_WIDTH;
        return x;
      });

      // Shooting
      const now = performance.now();
      if (keys.shoot && now - lastShotTimeRef.current > shootCooldown) {
        lastShotTimeRef.current = now;
        setBullets((prev) => [
          ...prev,
          {
            x: playerX + PLAYER_WIDTH / 2 - BULLET_WIDTH / 2,
            y: GAME_HEIGHT - PLAYER_HEIGHT - 10
          }
        ]);
      }

      // Move bullets
      setBullets((prevBullets) =>
        prevBullets
          .map((b) => ({ ...b, y: b.y - BULLET_SPEED }))
          .filter((b) => b.y + BULLET_HEIGHT > 0)
      );

      // Move enemies as a block
      setEnemies((prevEnemies) => {
        if (prevEnemies.length === 0) return prevEnemies;

        // Determine boundaries
        let minX = Infinity;
        let maxX = -Infinity;
        prevEnemies.forEach((e) => {
          if (e.alive) {
            if (e.x < minX) minX = e.x;
            if (e.x > maxX) maxX = e.x;
          }
        });

        let newDirection = enemyDirection;
        let newOffsetY = enemyOffsetY;

        if (minX <= 10 && enemyDirection === -1) {
          newDirection = 1;
          newOffsetY += ENEMY_STEP_DOWN;
        } else if (maxX + ENEMY_WIDTH >= GAME_WIDTH - 10 && enemyDirection === 1) {
          newDirection = -1;
          newOffsetY += ENEMY_STEP_DOWN;
        }

        // Apply Y offset if changed
        if (newOffsetY !== enemyOffsetY) {
          setEnemyOffsetY(newOffsetY);
        }
        if (newDirection !== enemyDirection) {
          setEnemyDirection(newDirection);
        }

        const moved = prevEnemies.map((e) => ({
          ...e,
          x: e.x + ENEMY_SPEED_X * newDirection
        }));

        // Check lose condition: any enemy too low
        const reachedBottom = moved.some(
          (e) =>
            e.alive &&
            e.y + enemyOffsetY + ENEMY_HEIGHT >= GAME_HEIGHT - PLAYER_HEIGHT - 30
        );
        if (reachedBottom) {
          setGameState('lose');
        }

        return moved;
      });

      // Handle bullet/enemy collisions
      setEnemies((prevEnemies) => {
        let updatedEnemies = prevEnemies.map((e) => ({ ...e }));
        let updatedBullets = [...bullets];

        updatedBullets.forEach((bullet, bulletIndex) => {
          updatedEnemies.forEach((enemy, enemyIndex) => {
            if (!enemy.alive) return;

            const ex = enemy.x;
            const ey = enemy.y + enemyOffsetY;

            if (
              bullet.x < ex + ENEMY_WIDTH &&
              bullet.x + BULLET_WIDTH > ex &&
              bullet.y < ey + ENEMY_HEIGHT &&
              bullet.y + BULLET_HEIGHT > ey
            ) {
              // Hit: kill enemy & remove bullet
              updatedEnemies[enemyIndex].alive = false;
              updatedBullets[bulletIndex] = null;
              setScore((prev) => prev + 100);
            }
          });
        });

        // Clean bullets after collision check
        setBullets(updatedBullets.filter((b) => b !== null));

        const aliveEnemies = updatedEnemies.filter((e) => e.alive);
        if (aliveEnemies.length === 0) {
          setGameState('win');
        }

        return updatedEnemies;
      });
    }, TICK_MS);

    return () => clearInterval(interval);
  }, [keys, gameState, enemyDirection, enemyOffsetY, bullets, playerX]);

  const handleExit = () => {
    navigate(DASHBOARD_ROUTE);
  };

  const handleRestart = () => {
    setPlayerX(GAME_WIDTH / 2 - PLAYER_WIDTH / 2);
    setBullets([]);
    setEnemies(createInitialEnemies());
    setEnemyDirection(1);
    setEnemyOffsetY(0);
    setGameState('playing');
    setScore(0);
  };

  // Styles
  const containerStyle = {
    minHeight: '100vh',
    background:
      'radial-gradient(circle at top, #020617 0, #020617 40%, #000 100%)',
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    color: 'white',
    fontFamily:
      '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
    padding: '1rem',
    gap: '1rem',
    position: 'relative'
  };

  const gameAreaStyle = {
    position: 'relative',
    width: GAME_WIDTH,
    height: GAME_HEIGHT,
    background:
      'linear-gradient(180deg, #020617 0%, #020617 60%, #000 100%)',
    border: '4px solid #4b5563',
    borderRadius: '10px',
    overflow: 'hidden',
    boxShadow: '0 0 25px rgba(0,0,0,0.8)'
  };

  const hudStyle = {
    display: 'flex',
    justifyContent: 'space-between',
    width: GAME_WIDTH,
    fontSize: '0.9rem',
    opacity: 0.9
  };

  return (
    <div style={containerStyle}>
      {/* Exit */}
      <button
        onClick={handleExit}
        style={{
          position: 'absolute',
          top: '1rem',
          right: '1rem',
          background: 'rgba(0,0,0,0.6)',
          borderRadius: '999px',
          border: '1px solid rgba(255,255,255,0.3)',
          color: 'white',
          padding: '0.4rem 0.7rem',
          cursor: 'pointer',
          fontSize: '0.85rem'
        }}
      >
        ‚úï Exit
      </button>

      <h1 style={{ fontSize: '2rem', textAlign: 'center' }}>
        üöÄ Starfield Defender
      </h1>
      <p style={{ opacity: 0.8, textAlign: 'center', maxWidth: 500 }}>
        Move with <strong>‚Üê ‚Üí / A D</strong>, shoot with{' '}
        <strong>Space / ‚Üë / W</strong>. Clear all invaders before they reach you.
      </p>

      <div style={hudStyle}>
        <div>Score: {score}</div>
        <div>
          Status:{' '}
          {gameState === 'playing'
            ? 'ENGAGED'
            : gameState === 'win'
            ? 'VICTORY'
            : 'CRITICAL FAILURE'}
        </div>
      </div>

      <div style={gameAreaStyle}>
        {/* Player */}
        <div
          style={{
            position: 'absolute',
            width: PLAYER_WIDTH,
            height: PLAYER_HEIGHT,
            left: playerX,
            bottom: 20,
            background:
              'linear-gradient(135deg, #22c55e, #16a34a)',
            borderRadius: '6px 6px 2px 2px',
            boxShadow: '0 0 15px rgba(34,197,94,0.8)',
            border: '2px solid #22c55e',
            transform: 'translateY(0)'
          }}
        >
          {/* little cockpit triangle */}
          <div
            style={{
              width: 0,
              height: 0,
              borderLeft: `${PLAYER_WIDTH / 2}px solid transparent`,
              borderRight: `${PLAYER_WIDTH / 2}px solid transparent`,
              borderBottom: '10px solid #bbf7d0',
              position: 'absolute',
              top: -10,
              left: 0
            }}
          />
        </div>

        {/* Bullets */}
        {bullets.map((b, i) => (
          <div
            key={i}
            style={{
              position: 'absolute',
              width: BULLET_WIDTH,
              height: BULLET_HEIGHT,
              left: b.x,
              top: b.y,
              background:
                'linear-gradient(180deg,#facc15,#f97316)',
              boxShadow: '0 0 8px rgba(250,204,21,0.9)',
              borderRadius: '999px'
            }}
          />
        ))}

        {/* Enemies */}
        {enemies.map(
          (e, i) =>
            e.alive && (
              <div
                key={i}
                style={{
                  position: 'absolute',
                  width: ENEMY_WIDTH,
                  height: ENEMY_HEIGHT,
                  left: e.x,
                  top: e.y + enemyOffsetY,
                  background: 'linear-gradient(135deg,#f97316,#db2777)',
                  borderRadius: '4px',
                  border: '2px solid #fb7185',
                  boxShadow: '0 0 10px rgba(251,113,133,0.8)',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  fontSize: '0.7rem'
                }}
              >
                üëæ
              </div>
            )
        )}

        {/* End-of-game overlay */}
        {gameState !== 'playing' && (
          <div
            style={{
              position: 'absolute',
              inset: 0,
              background: 'rgba(0,0,0,0.75)',
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'center',
              justifyContent: 'center',
              gap: '0.75rem',
              textAlign: 'center',
              padding: '1rem'
            }}
          >
            <h2 style={{ fontSize: '1.6rem', marginBottom: '0.25rem' }}>
              {gameState === 'win' ? 'VICTORY!' : 'MISSION FAILED'}
            </h2>
            <p style={{ opacity: 0.8 }}>
              {gameState === 'win'
                ? 'You cleared the wave of invaders. The network is safe... for now.'
                : 'The invaders breached your defenses. Recalibrate and try again.'}
            </p>
            <div style={{ display: 'flex', gap: '0.5rem', marginTop: '0.5rem' }}>
              <button
                onClick={handleRestart}
                style={{
                  padding: '0.6rem 1.1rem',
                  borderRadius: '999px',
                  border: 'none',
                  background:
                    'linear-gradient(135deg,#22c55e,#16a34a)',
                  color: 'white',
                  fontWeight: 'bold',
                  cursor: 'pointer'
                }}
              >
                Play Again
              </button>
              <button
                onClick={handleExit}
                style={{
                  padding: '0.6rem 1.1rem',
                  borderRadius: '999px',
                  border: '1px solid rgba(148,163,184,0.6)',
                  background: 'rgba(15,23,42,0.9)',
                  color: 'white',
                  cursor: 'pointer'
                }}
              >
                Back to Dashboard
              </button>
            </div>
          </div>
        )}
      </div>

      {gameState === 'playing' && (
        <button
          onClick={handleRestart}
          style={{
            marginTop: '0.4rem',
            padding: '0.35rem 0.9rem',
            borderRadius: '999px',
            border: '1px solid rgba(148,163,184,0.6)',
            background: 'rgba(15,23,42,0.7)',
            color: 'white',
            fontSize: '0.85rem',
            cursor: 'pointer'
          }}
        >
          Reset Wave
        </button>
      )}
    </div>
  );
}

function createInitialEnemies() {
  const enemies = [];
  const startX = (GAME_WIDTH - (ENEMY_COLS - 1) * ENEMY_X_SPACING) / 2;

  for (let row = 0; row < ENEMY_ROWS; row++) {
    for (let col = 0; col < ENEMY_COLS; col++) {
      enemies.push({
        x: startX + col * ENEMY_X_SPACING,
        y: ENEMY_START_Y + row * ENEMY_Y_SPACING,
        alive: true
      });
    }
  }
  return enemies;
}
